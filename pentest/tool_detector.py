"""
Tool detection module for Instability v3.

Detects installed pentesting tools across different platforms,
verifies versions, and provides installation recommendations.
"""

import os
import subprocess
import platform
import glob
import re
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime
from colorama import Fore, Style, init as colorama_init

# Import configuration
from config import (
    TOOL_PATHS, TOOL_INSTALL_COMMANDS, TOOL_DETECTION_TIMEOUT,
    get_platform_install_command
)

# Initialize colorama for colored output
colorama_init(autoreset=True)


def scan_for_tools(force_refresh: bool = False) -> Dict[str, Any]:
    """
    Scan for all detectable tools and return comprehensive inventory.
    
    Args:
        force_refresh: If True, re-scan instead of using cached results
        
    Returns:
        Tool inventory dictionary following the defined schema
    """
    scan_start = datetime.now()
    
    # Try to load existing inventory if not forcing refresh
    if not force_refresh:
        cached_inventory = load_tool_inventory_cache()
        if cached_inventory:
            return cached_inventory
    
    print("Scanning for pentesting tools...")
    
    inventory = {
        "metadata": {
            "last_updated": scan_start.isoformat(),
            "scan_duration": 0.0,
            "platform": platform.system().lower(),
            "python_version": platform.python_version()
        },
        "tools": {}
    }
    
    # Define tools to detect with their categories
    tools_to_detect = {
        "nmap": {
            "category": "network_scanning",
            "description": "Network exploration tool and security scanner"
        },
        "nuclei": {
            "category": "vulnerability_scanning", 
            "description": "Fast vulnerability scanner with templates"
        },
        "httpx": {
            "category": "web_discovery",
            "description": "Fast HTTP toolkit for web discovery"
        },
        "feroxbuster": {
            "category": "web_discovery",
            "description": "Fast directory/file enumeration tool"
        },
        "gobuster": {
            "category": "web_discovery",
            "description": "Directory/DNS enumeration tool"
        },
        "hydra": {
            "category": "exploitation",
            "description": "Network login cracker"
        },
        "sqlmap": {
            "category": "exploitation",
            "description": "SQL injection testing tool"
        },
        "traceroute": {
            "category": "network_diagnostics",
            "description": "Network path tracing tool"
        }
    }
    
    # Detect each tool
    for tool_name, tool_info in tools_to_detect.items():
        print(f"  Checking {tool_name}...")
        detection_result = detect_tool_installation(tool_name)
        
        # Add metadata to detection result
        detection_result.update({
            "category": tool_info["category"],
            "description": tool_info["description"],
            "last_checked": datetime.now().isoformat()
        })
        
        inventory["tools"][tool_name] = detection_result
    
    # Calculate scan duration
    scan_end = datetime.now()
    inventory["metadata"]["scan_duration"] = (scan_end - scan_start).total_seconds()
    
    # Save inventory to cache
    save_tool_inventory_cache(inventory)
    
    # Print summary
    found_count = len([t for t in inventory["tools"].values() if t["found"]])
    total_count = len(inventory["tools"])
    print(f"[{Fore.GREEN}OK{Style.RESET_ALL}] Tool scan complete: {found_count}/{total_count} tools found")
    
    return inventory


def detect_tool_installation(tool_name: str) -> Dict[str, Any]:
    """
    Detect if a specific tool is installed and get its details.
    
    Args:
        tool_name: Name of the tool to detect
        
    Returns:
        Detection result dictionary
    """
    check_start = datetime.now()
    
    result = {
        "found": False,
        "path": None,
        "version": None,
        "install_command": None,
        "check_duration": 0.0
    }
    
    try:
        # First, try to find the tool in PATH
        path_result = check_tool_in_path(tool_name)
        if path_result["found"]:
            result.update(path_result)
        else:
            # Try predefined paths
            predefined_result = check_predefined_paths(tool_name)
            if predefined_result["found"]:
                result.update(predefined_result)
        
        # If tool is found, try to get version
        if result["found"] and result["path"]:
            version = get_tool_version(tool_name, result["path"])
            if version:
                result["version"] = version
        
        # If tool is not found, provide installation command
        if not result["found"]:
            result["install_command"] = get_platform_install_command(tool_name)
    
    except Exception as e:
        print(f"    Warning: Error detecting {tool_name}: {Fore.RED}{e}{Style.RESET_ALL}")
        result["install_command"] = get_platform_install_command(tool_name)
    
    # Calculate check duration
    check_end = datetime.now()
    result["check_duration"] = (check_end - check_start).total_seconds()
    
    return result


def check_tool_in_path(tool_name: str) -> Dict[str, Any]:
    """
    Check if a tool is available in the system PATH.
    
    Args:
        tool_name: Name of the tool to check
        
    Returns:
        Dictionary with found status and path
    """
    try:
        # Use 'which' on Unix/macOS or 'where' on Windows
        if platform.system() == "Windows":
            cmd = ["where", tool_name]
        else:
            cmd = ["which", tool_name]
        
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=TOOL_DETECTION_TIMEOUT
        )
        
        if result.returncode == 0 and result.stdout.strip():
            path = result.stdout.strip().split('\n')[0]  # Get first result
            return {"found": True, "path": path}
        else:
            return {"found": False, "path": None}
    
    except Exception:
        return {"found": False, "path": None}


def check_predefined_paths(tool_name: str) -> Dict[str, Any]:
    """
    Check predefined installation paths for a tool.
    
    Args:
        tool_name: Name of the tool to check
        
    Returns:
        Dictionary with found status and path
    """
    if tool_name not in TOOL_PATHS:
        return {"found": False, "path": None}
    
    for path_pattern in TOOL_PATHS[tool_name]:
        try:
            # Handle glob patterns (e.g., /usr/local/Cellar/nmap/*/bin/nmap)
            if '*' in path_pattern:
                matching_paths = glob.glob(path_pattern)
                for path in matching_paths:
                    if os.path.isfile(path) and os.access(path, os.X_OK):
                        return {"found": True, "path": path}
            else:
                # Direct path check
                if os.path.isfile(path_pattern) and os.access(path_pattern, os.X_OK):
                    return {"found": True, "path": path_pattern}
        
        except Exception:
            continue
    
    return {"found": False, "path": None}


def get_tool_version(tool_name: str, tool_path: str) -> Optional[str]:
    """
    Get the version of a detected tool.
    
    Args:
        tool_name: Name of the tool
        tool_path: Path to the tool executable
        
    Returns:
        Version string if detected, None otherwise
    """
    version_commands = {
        "nmap": ["--version"],
        "nuclei": ["-version"],
        "httpx": ["-version"],
        "feroxbuster": ["--version"],
        "gobuster": ["-h"],  # gobuster shows version in help
        "hydra": ["-h"],     # hydra shows version in help
        "sqlmap": ["--version"],
        "traceroute": ["--version"] if platform.system() != "Windows" else []
    }
    
    if tool_name not in version_commands:
        return None
    
    try:
        cmd = [tool_path] + version_commands[tool_name]
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=TOOL_DETECTION_TIMEOUT
        )
        
        # Parse version from output
        version = parse_version_output(tool_name, result.stdout + result.stderr)
        return version
    
    except Exception:
        return None


def parse_version_output(tool_name: str, output: str) -> Optional[str]:
    """
    Parse version information from tool output.
    
    Args:
        tool_name: Name of the tool
        output: Combined stdout and stderr from version command
        
    Returns:
        Parsed version string or None
    """
    # Common version patterns
    version_patterns = [
        r'version\s+(\d+\.\d+(?:\.\d+)?)',
        r'v(\d+\.\d+(?:\.\d+)?)',
        r'(\d+\.\d+(?:\.\d+)?)',
        r'Version:\s*(\d+\.\d+(?:\.\d+)?)',
    ]
    
    # Tool-specific patterns
    tool_patterns = {
        "nmap": [r'Nmap version (\d+\.\d+(?:\.\d+)?)'],
        "nuclei": [r'nuclei version (\d+\.\d+(?:\.\d+)?)'],
        "httpx": [r'httpx version (\d+\.\d+(?:\.\d+)?)'],
        "feroxbuster": [r'feroxbuster (\d+\.\d+(?:\.\d+)?)'],
        "hydra": [r'Hydra v(\d+\.\d+(?:\.\d+)?)', r'Hydra \((\d+\.\d+(?:\.\d+)?)\)'],
        "sqlmap": [r'sqlmap version (\d+\.\d+(?:\.\d+)?)']
    }
    
    # Use tool-specific patterns first
    patterns_to_try = tool_patterns.get(tool_name, []) + version_patterns
    
    for pattern in patterns_to_try:
        match = re.search(pattern, output, re.IGNORECASE)
        if match:
            return match.group(1)
    
    return None


def get_missing_tools(inventory: Dict[str, Any]) -> List[str]:
    """
    Get list of tools that are not installed.
    
    Args:
        inventory: Tool inventory dictionary
        
    Returns:
        List of missing tool names
    """
    missing = []
    for tool_name, tool_data in inventory.get("tools", {}).items():
        if not tool_data.get("found", False):
            missing.append(tool_name)
    return missing


def get_available_tools(inventory: Dict[str, Any]) -> List[str]:
    """
    Get list of tools that are installed and available.
    
    Args:
        inventory: Tool inventory dictionary
        
    Returns:
        List of available tool names
    """
    available = []
    for tool_name, tool_data in inventory.get("tools", {}).items():
        if tool_data.get("found", False):
            available.append(tool_name)
    return available


def get_tools_by_category(inventory: Dict[str, Any], category: str) -> List[str]:
    """
    Get list of tool names in a specific category.
    
    Args:
        inventory: Tool inventory dictionary
        category: Tool category to filter by
        
    Returns:
        List of tool names in the category
    """
    tools_in_category = []
    for tool_name, tool_data in inventory.get("tools", {}).items():
        if tool_data.get("category") == category:
            tools_in_category.append(tool_name)
    return tools_in_category


def print_tool_recommendations(missing_tools: List[str]) -> None:
    """
    Print installation recommendations for missing tools.
    
    Args:
        missing_tools: List of missing tool names
    """
    if not missing_tools:
        print(f"[{Fore.GREEN}OK{Style.RESET_ALL}] All tools are installed!")
        return
    
    print(f"\n[{Fore.YELLOW}WARN{Style.RESET_ALL}] Missing {len(missing_tools)} recommended tools:")
    
    for tool_name in missing_tools:
        install_cmd = get_platform_install_command(tool_name)
        print(f"\n{tool_name}:")
        print(f"   Installation: {install_cmd}")
        
        # Provide additional context for critical tools
        if tool_name in ["nmap", "nuclei"]:
            print(f"   [{Fore.YELLOW}WARN{Style.RESET_ALL}] This is a critical tool for pentesting operations")


def load_tool_inventory_cache() -> Optional[Dict[str, Any]]:
    """
    Load cached tool inventory if it exists and is recent.
    
    Returns:
        Cached inventory dictionary or None
    """
    cache_file = os.path.join("memory", "tool_inventory_cache.json")
    
    if not os.path.exists(cache_file):
        return None
    
    try:
        import json
        with open(cache_file, 'r') as f:
            cached_data = json.load(f)
        
        # Check if cache is recent (within last hour)
        from datetime import timedelta
        last_updated = datetime.fromisoformat(cached_data["metadata"]["last_updated"])
        if datetime.now() - last_updated < timedelta(hours=1):
            return cached_data
    
    except Exception:
        pass
    
    return None


def save_tool_inventory_cache(inventory: Dict[str, Any]) -> None:
    """
    Save tool inventory to cache file.
    
    Args:
        inventory: Tool inventory dictionary to cache
    """
    try:
        import json
        from config import get_memory_dir
        
        # Ensure memory directory exists
        get_memory_dir()
        
        cache_file = os.path.join("memory", "tool_inventory_cache.json")
        temp_file = f"{cache_file}.tmp"
        
        with open(temp_file, 'w') as f:
            json.dump(inventory, f, indent=2)
        
        os.rename(temp_file, cache_file)
    
    except Exception as e:
        print(f"Warning: Failed to cache tool inventory: {Fore.RED}{e}{Style.RESET_ALL}")


def format_tool_inventory_summary(inventory: Dict[str, Any]) -> str:
    """
    Format tool inventory into a readable summary.
    
    Args:
        inventory: Tool inventory dictionary
        
    Returns:
        Formatted summary string
    """
    tools = inventory.get("tools", {})
    found_tools = [name for name, data in tools.items() if data.get("found")]
    missing_tools = [name for name, data in tools.items() if not data.get("found")]
    
    summary = f"Tool Inventory Summary\n"
    summary += f"   Found: {len(found_tools)}/{len(tools)} tools\n"
    
    if found_tools:
        summary += f"\nAvailable tools:\n"
        for tool_name in sorted(found_tools):
            tool_data = tools[tool_name]
            version = tool_data.get("version", "unknown version")
            summary += f"   • {tool_name} ({version})\n"
    
    if missing_tools:
        summary += f"\nMissing tools:\n"
        for tool_name in sorted(missing_tools):
            summary += f"   • {tool_name}\n"
    
    return summary


# Quick test function for development
def test_tool_detector():
    """Test function for development purposes."""
    print("Testing tool detector module...")
    
    # Test individual tool detection
    print("\n1. Testing individual tool detection:")
    test_tools = ["nmap", "curl", "nonexistent_tool"]
    for tool in test_tools:
        result = detect_tool_installation(tool)
        status = "✓" if result["found"] else "✗"
        print(f"   {status} {tool}: {result}")
    
    # Test full scan
    print("\n2. Testing full tool scan:")
    inventory = scan_for_tools(force_refresh=True)
    
    # Print summary
    print("\n3. Tool inventory summary:")
    summary = format_tool_inventory_summary(inventory)
    print(summary)
    
    # Test missing tools recommendations
    missing = get_missing_tools(inventory)
    if missing:
        print_tool_recommendations(missing[:3])  # Show first 3
    
    return inventory


if __name__ == "__main__":
    test_tool_detector()