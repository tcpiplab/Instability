"""
Nmap Wrapper Module

Provides comprehensive nmap functionality with standardized interfaces.
Part of the instability.py v3 pentesting toolkit.
"""

import json
import os
import re
import subprocess
from datetime import datetime
from typing import Dict, Any, List, Union

from colorama import Fore

# Import centralized configuration
from config import (
    get_timeout, get_common_ports
    )
from pentest.tool_detector import detect_tool_installation


def run_nmap_scan(target: str, scan_type: str = "basic", ports: Union[str, List] = None,
                 output_format: str = "dict", timeout: int = None, silent: bool = False) -> Dict[str, Any]:
    """
    Run nmap scan with specified parameters.
    
    Args:
        target: Target IP, hostname, or CIDR range
        scan_type: Type of scan (basic, syn, udp, comprehensive, stealth, version, os)
        ports: Port specification (string like "80,443" or list like [80, 443]) (e.g., "80,443", "1-1000", "top-ports 100")
        output_format: Output format (dict, xml, json)
        timeout: Scan timeout in seconds
        silent: Suppress console output if True
        
    Returns:
        Dict containing scan results and metadata
    """
    if not silent:
        is_privileged = (os.getuid() == 0) if hasattr(os, 'getuid') else False
        privilege_note = " (privileged)" if is_privileged else " (unprivileged)"
        print(f"{Fore.CYAN}Running nmap {scan_type} scan{privilege_note} on {target}...{Fore.RESET}")
    
    result = {
        "success": False,
        "scan_type": scan_type,
        "target": target,
        "ports_scanned": ports,
        "start_time": datetime.now().isoformat(),
        "end_time": None,
        "duration_seconds": None,
        "hosts_found": 0,
        "ports_found": 0,
        "hosts": {},
        "summary": None,
        "raw_output": None,
        "error": None
    }
    
    # Use configuration-based timeout if not specified
    if timeout is None:
        timeout = get_timeout("nmap", scan_type)
    
    # Use configuration-based ports if not specified
    if ports is None:
        if scan_type in ["comprehensive", "service_scan"]:
            ports = get_common_ports("tcp")
        else:
            ports = get_common_ports("common")
    
    # Check if nmap is available
    nmap_check = detect_tool_installation("nmap")
    if not nmap_check["found"]:
        result["error"] = "nmap not found. Please install nmap first."
        if not silent:
            print(f"{Fore.RED}nmap not found. Install with: {nmap_check.get('install_command', 'package manager')}{Fore.RESET}")
        return result
    
    nmap_path = nmap_check["path"]
    
    try:
        # Build nmap command
        cmd = _build_nmap_command(nmap_path, target, scan_type, ports)
        
        if not silent:
            print(f"{Fore.YELLOW}Executing: {' '.join(cmd)}{Fore.RESET}")
        
        start_time = datetime.now()
        
        # Execute nmap
        process = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=timeout
        )
        
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        
        result["end_time"] = end_time.isoformat()
        result["duration_seconds"] = round(duration, 2)
        result["raw_output"] = process.stdout
        
        if process.returncode == 0:
            # Parse nmap output
            parsed_results = _parse_nmap_output(process.stdout, scan_type)
            result.update(parsed_results)
            result["success"] = True
            
            if not silent:
                print(f"{Fore.GREEN}Scan completed in {duration:.1f}s{Fore.RESET}")
                print(f"{Fore.GREEN}  Found {result['hosts_found']} hosts, {result['ports_found']} open ports{Fore.RESET}")
        else:
            stderr_text = process.stderr.strip()
            stdout_text = process.stdout.strip()
            
            # Add detailed error information for debugging
            result["stderr"] = stderr_text
            result["exit_code"] = process.returncode
            result["command_executed"] = " ".join(cmd)
            
            # Use enhanced security detection and rich markdown generation
            blocking_type = _detect_security_blocking_type(stderr_text, process.returncode)
            
            if blocking_type in ["macos_security", "privilege_required", "firewall_blocked", "policy_blocked"]:
                result["error_type"] = "security_restriction"
                
                # Generate rich markdown manual command examples
                rich_markdown = _generate_rich_markdown_manual_commands(target, scan_type, ports, blocking_type)
                result["manual_commands_markdown"] = rich_markdown
                
                # Set appropriate error message based on blocking type
                if blocking_type == "macos_security":
                    result["error"] = "macOS Security & Privacy settings are blocking nmap's raw socket operations"
                elif blocking_type == "privilege_required":
                    result["error"] = "This scan type requires root/administrator privileges"
                elif blocking_type == "firewall_blocked":
                    result["error"] = "Target network or firewall is blocking scan attempts"
                elif blocking_type == "policy_blocked":
                    result["error"] = "Corporate security policy or EDR is blocking nmap"
                
                # Add the rich markdown to the error message for text output
                result["error"] += f"\n\n{rich_markdown}"
                
                # Generate basic manual command for backward compatibility
                manual_cmd = _generate_manual_nmap_command(target, scan_type, ports)
                result["manual_command"] = manual_cmd
                
                if not silent:
                    print(f"{Fore.YELLOW}Security restriction detected: {result['error'].split('.')[0]}{Fore.RESET}")
                    print(f"{Fore.CYAN}See manual_commands_markdown field for detailed alternatives{Fore.RESET}")
                
            elif blocking_type == "network_unreachable":
                result["error"] = f"nmap failed (network unreachable): {stderr_text}"
                result["error"] += "\nSuggestion: Check network connectivity and target reachability"
                result["error_type"] = "network"
                if not silent:
                    print(f"{Fore.RED}nmap failed: {stderr_text}{Fore.RESET}")
            elif "invalid target" in stderr_text.lower() or "failed to resolve" in stderr_text.lower():
                result["error"] = f"nmap failed (invalid target): {stderr_text}"
                result["error"] += f"\nSuggestion: Check target format for '{target}'"
                result["error_type"] = "invalid_target"
                if not silent:
                    print(f"{Fore.RED}nmap failed: {stderr_text}{Fore.RESET}")
            elif "not found" in stderr_text.lower() and "command" in stderr_text.lower():
                result["error"] = f"nmap command not found: {stderr_text}"
                result["error"] += "\nSuggestion: Install nmap with 'brew install nmap' or check PATH"
                result["error_type"] = "tool_missing"
                if not silent:
                    print(f"{Fore.RED}nmap not found: {stderr_text}{Fore.RESET}")
            else:
                # Generic error with enhanced manual commands
                result["error"] = f"nmap failed (exit code {process.returncode}): {stderr_text}"
                result["error_type"] = "execution"
                
                # Still provide helpful manual command alternatives
                rich_markdown = _generate_rich_markdown_manual_commands(target, scan_type, ports, "unknown")
                result["manual_commands_markdown"] = rich_markdown
                manual_cmd = _generate_manual_nmap_command(target, scan_type, ports)
                result["manual_command"] = manual_cmd
                
                if not silent:
                    print(f"{Fore.RED}nmap failed: {stderr_text}{Fore.RESET}")
                    print(f"{Fore.CYAN}Manual alternatives available in result['manual_commands_markdown']{Fore.RESET}")
            
            # Add additional debugging info if stdout contains useful info
            if stdout_text and stdout_text != stderr_text:
                result["error"] += f"\nAdditional output: {stdout_text}"
    
    except subprocess.TimeoutExpired:
        result["error"] = f"Scan timeout after {timeout}s"
        if not silent:
            print(f"{Fore.RED}Scan timeout after {timeout}s{Fore.RESET}")
    
    except Exception as e:
        result["error"] = f"Unexpected error: {str(e)}"
        if not silent:
            print(f"{Fore.RED}Error: {e}{Fore.RESET}")
    
    return result

def quick_port_scan(target: str, ports: str = "80,443,22,21,25,53,110,143,993,995", silent: bool = False) -> Dict[str, Any]:
    """
    Quick port scan for common services.
    
    Args:
        target: Target IP or hostname
        ports: Comma-separated list of ports to scan
        silent: Suppress console output if True
        
    Returns:
        Dict containing scan results
    """
    return run_nmap_scan(
        target=target,
        scan_type="basic",
        ports=ports,
        timeout=60,
        silent=silent
    )

def network_discovery(network: str, silent: bool = False) -> Dict[str, Any]:
    """
    Discover live hosts on a network.
    
    Args:
        network: Network in CIDR notation (e.g., "192.168.1.0/24")
        silent: Suppress console output if True
        
    Returns:
        Dict containing discovered hosts
    """
    return run_nmap_scan(
        target=network,
        scan_type="ping",
        timeout=120,
        silent=silent
    )

def service_version_scan(target: str, ports: str = None, silent: bool = False) -> Dict[str, Any]:
    """
    Scan for service versions on open ports.
    
    Args:
        target: Target IP or hostname
        ports: Port specification (string like "80,443" or list like [80, 443]) (default: common ports)
        silent: Suppress console output if True
        
    Returns:
        Dict containing service version information
    """
    return run_nmap_scan(
        target=target,
        scan_type="version",
        ports=ports or "top-ports 1000",
        timeout=300,
        silent=silent
    )

def os_detection_scan(target: str, silent: bool = False) -> Dict[str, Any]:
    """
    Attempt to detect target operating system.
    
    Args:
        target: Target IP or hostname
        silent: Suppress console output if True
        
    Returns:
        Dict containing OS detection results
    """
    return run_nmap_scan(
        target=target,
        scan_type="os",
        timeout=180,
        silent=silent
    )

def comprehensive_scan(target: str, silent: bool = False) -> Dict[str, Any]:
    """
    Comprehensive scan with service detection and OS fingerprinting.
    
    Args:
        target: Target IP or hostname
        silent: Suppress console output if True
        
    Returns:
        Dict containing comprehensive scan results
    """
    return run_nmap_scan(
        target=target,
        scan_type="comprehensive",
        timeout=600,
        silent=silent
    )

def _build_nmap_command(nmap_path: str, target: str, scan_type: str, ports: Union[str, List] = None) -> List[str]:
    """
    Build nmap command based on scan type and parameters.
    
    Args:
        nmap_path: Path to nmap executable
        target: Target specification
        scan_type: Type of scan to perform
        ports: Port specification (string like "80,443" or list like [80, 443])
        
    Returns:
        List of command arguments
    """
    cmd = [nmap_path]
    
    # Check if we're running with privileges
    is_privileged = os.getuid() == 0 if hasattr(os, 'getuid') else False
    
    # Base scan type configurations - use unprivileged scans by default
    if is_privileged:
        # Privileged scan configurations
        scan_configs = {
            "basic": ["-sS"],  # SYN scan
            "syn": ["-sS"],
            "tcp": ["-sT"],    # TCP connect scan
            "udp": ["-sU"],    # UDP scan
            "ping": ["-sn"],   # Ping scan (no port scan)
            "stealth": ["-sS", "-f", "-T2"],  # Stealth scan
            "version": ["-sV"],  # Version detection
            "os": ["-O"],      # OS detection
            "comprehensive": ["-sS", "-sV", "-O", "-A"],  # Comprehensive
            "aggressive": ["-A", "-T4"],  # Aggressive scan
        }
    else:
        # Unprivileged scan configurations
        scan_configs = {
            "basic": ["-sT"],  # TCP connect scan (no root required)
            "syn": ["-sT"],    # Fallback to TCP connect
            "tcp": ["-sT"],    # TCP connect scan
            "udp": ["-sU"],    # UDP scan (may still need privileges on some systems)
            "ping": ["-sn"],   # Ping scan (no port scan)
            "stealth": ["-sT", "-T2"],  # Stealth TCP connect
            "version": ["-sT", "-sV"],  # Version detection with TCP connect
            "os": ["-sT"],     # OS detection requires privileges, fallback to TCP
            "comprehensive": ["-sT", "-sV", "-A"],  # Comprehensive without privileged features
            "aggressive": ["-sT", "-A", "-T4"],  # Aggressive scan with TCP connect
        }
    
    # Add scan type flags
    if scan_type in scan_configs:
        cmd.extend(scan_configs[scan_type])
    else:
        # Default to TCP connect scan (works without privileges)
        cmd.extend(["-sT"])
    
    # Add port specification
    if ports and scan_type != "ping":
        # Handle case where ports might be passed as a list instead of string
        if isinstance(ports, list):
            ports = ",".join(str(p) for p in ports)
        
        if isinstance(ports, str) and ports.startswith("top-ports"):
            # Handle top-ports specification
            num_ports = ports.split()[-1]
            cmd.extend(["--top-ports", num_ports])
        elif "," in str(ports) or "-" in str(ports):
            # Handle port list or range
            cmd.extend(["-p", str(ports)])
        else:
            # Single port
            cmd.extend(["-p", str(ports)])
    elif scan_type == "udp":
        # Default UDP ports if none specified
        cmd.extend(["--top-ports", "100"])
    
    # Add common useful flags
    cmd.extend([
        "-n",           # No DNS resolution (faster)
        "--open",       # Only show open ports
        "--reason",     # Show reason for port state
    ])
    
    # Add timing template based on scan type
    if scan_type == "stealth":
        cmd.extend(["-T2"])  # Polite timing
    elif scan_type in ["comprehensive", "aggressive"]:
        cmd.extend(["-T4"])  # Aggressive timing
    else:
        cmd.extend(["-T3"])  # Normal timing
    
    # Add target
    cmd.append(target)
    
    return cmd

def _detect_security_blocking_type(stderr: str, exit_code: int) -> str:
    """
    Detect the type of security blocking based on error output.
    
    Args:
        stderr: Standard error output from nmap
        exit_code: Process exit code
        
    Returns:
        String describing the blocking type
    """
    stderr_lower = stderr.lower()
    
    # macOS Security & Privacy restrictions
    if ("so_error" in stderr_lower or 
        "network is down" in stderr_lower or 
        "bailing scan" in stderr_lower or
        "sendto in send_ip_packet_sd" in stderr_lower or
        "socket troubles" in stderr_lower):
        return "macos_security"
    
    # Root/privilege requirements
    elif ("requires root privileges" in stderr_lower or
          "operation not permitted" in stderr_lower or
          "permission denied" in stderr_lower):
        return "privilege_required"
    
    # Firewall/network policy blocking
    elif ("connection refused" in stderr_lower or
          "host prohibited" in stderr_lower or
          "administratively prohibited" in stderr_lower or
          "filtered" in stderr_lower):
        return "firewall_blocked"
    
    # Corporate/EDR blocking
    elif ("access denied" in stderr_lower or
          "security policy" in stderr_lower or
          "blocked by policy" in stderr_lower or
          exit_code == 1 and "error" in stderr_lower):
        return "policy_blocked"
    
    # Network unreachable (not a security issue)
    elif ("network unreachable" in stderr_lower or
          "no route to host" in stderr_lower):
        return "network_unreachable"
    
    else:
        return "unknown"

def _generate_rich_markdown_manual_commands(target: str, scan_type: str, ports: str = None, blocking_type: str = "unknown") -> str:
    """
    Generate rich markdown formatted manual command examples with context-aware suggestions.
    
    Args:
        target: Target IP, hostname, or CIDR range
        scan_type: Type of scan to perform
        ports: Port specification (string like "80,443" or list like [80, 443])
        blocking_type: Type of security blocking detected
        
    Returns:
        Rich markdown string with manual command examples and explanations
    """
    # Generate base command
    base_cmd = _generate_manual_nmap_command(target, scan_type, ports)
    
    # Create context-aware suggestions based on blocking type
    if blocking_type == "macos_security":
        return f"""## 🔒 macOS Security Restrictions Detected

Your system's Security & Privacy settings are blocking nmap's raw socket operations.

### **Recommended Solution:**
```bash
# Use TCP connect scan (no root required, bypasses raw socket restrictions)
{base_cmd.replace('-sS', '-sT')}
```

### **Alternative Commands:**
```bash
# Basic TCP scan with common ports
nmap -sT -p 80,443,22,21,25,53 {target}

# Service version detection (safe for restricted environments)
nmap -sT -sV -p 80,443,22,21,25,53 {target}

# Full TCP scan (slower but works around restrictions)
nmap -sT -p- {target}
```

### **Why This Happens:**
- macOS restricts raw socket access for security
- SYN scans (`-sS`) require raw sockets
- TCP connect scans (`-sT`) work with standard sockets

### **To Enable Raw Socket Access:**
1. Run nmap with `sudo` (requires admin privileges)
2. Or permanently allow in System Preferences > Security & Privacy"""

    elif blocking_type == "privilege_required":
        return f"""## 🔐 Root Privileges Required

This scan type requires root/administrator privileges.

### **Run with Privileges:**
```bash
# Run with sudo (Linux/macOS)
sudo {base_cmd}

# Run as Administrator (Windows)
# Right-click Command Prompt > "Run as Administrator"
{base_cmd}
```

### **Alternative (No Root Required):**
```bash
# TCP connect scan (works without root)
{base_cmd.replace('-sS', '-sT').replace('-O', '')}

# Basic connectivity check
nmap -sT -p 80,443,22 {target}
```

### **Why Root is Needed:**
- SYN scans (`-sS`) require raw sockets
- OS detection (`-O`) needs raw packet crafting
- UDP scans (`-sU`) require raw sockets"""

    elif blocking_type == "firewall_blocked":
        return f"""## 🛡️ Firewall/Network Policy Blocking

The target network or firewall is blocking scan attempts.

### **Stealthy Alternatives:**
```bash
# Slower, more evasive scan
nmap -sT -T1 -p 80,443,22 {target}

# Fragment packets to evade simple firewalls
nmap -sS -f -T2 {target}

# Use decoy sources to hide your scan
nmap -sS -D RND:10 {target}

# Try specific protocols
nmap -sU -p 53,161,123 {target}  # UDP scan
nmap -sT -p 80,443,8080,8443 {target}  # Common web ports
```

### **Alternative Approach:**
```bash
# Basic connectivity test first
ping {target}
telnet {target} 80
nc -zv {target} 80 443 22
```"""

    elif blocking_type == "policy_blocked":
        return f"""## 🏢 Corporate/EDR Policy Blocking

Your organization's security policy or EDR is blocking nmap.

### **Policy-Friendly Alternatives:**
```bash
# Basic connectivity testing
ping {target}
traceroute {target}
telnet {target} 80
nc -zv {target} 80 443 22

# Use built-in tools instead
nslookup {target}
dig {target}
```

### **Minimal nmap Commands:**
```bash
# Simple ping scan (least threatening)
nmap -sn {target}

# Basic TCP check on specific ports
nmap -sT -p 80,443 {target}
```

### **Note:**
- Check with your IT security team before running scans
- Some organizations have approved scanning tools
- Consider using web-based port checkers for external targets"""

    else:
        return f"""## 🔧 Manual nmap Command

**Primary Command:**
```bash
{base_cmd}
```

### **Alternative Approaches:**
```bash
# TCP connect scan (no root required)
{base_cmd.replace('-sS', '-sT')}

# Basic port scan
nmap -sT -p 80,443,22,21,25,53 {target}

# Service detection
nmap -sT -sV -p 80,443,22 {target}

# Comprehensive scan
nmap -sT -sV -sC -p- {target}
```

### **Troubleshooting Tips:**
1. Try TCP connect scan (`-sT`) instead of SYN scan (`-sS`)
2. Run with `sudo` if permission errors occur
3. Use specific ports (`-p 80,443`) instead of port ranges
4. Add `-v` for verbose output to see what's happening"""

def _generate_manual_nmap_command(target: str, scan_type: str, ports: Union[str, List] = None) -> str:
    """
    Generate a manual nmap command string that users can run in their terminal.
    
    Args:
        target: Target IP, hostname, or CIDR range
        scan_type: Type of scan to perform
        ports: Port specification (string like "80,443" or list like [80, 443])
        
    Returns:
        String containing the manual nmap command
    """
    cmd_parts = ["nmap"]
    
    # Map scan types to manual command flags
    scan_flags = {
        "basic": ["-sS"],  # Default to SYN scan for manual commands
        "syn": ["-sS"],
        "tcp": ["-sT"],
        "udp": ["-sU"],
        "ping": ["-sn"],
        "stealth": ["-sS", "-f", "-T2"],
        "version": ["-sV"],
        "os": ["-O"],
        "comprehensive": ["-sS", "-sV", "-O", "-A"],
        "aggressive": ["-A", "-T4"]
    }
    
    # Add scan type flags
    if scan_type in scan_flags:
        cmd_parts.extend(scan_flags[scan_type])
    else:
        cmd_parts.extend(["-sS"])  # Default to SYN scan
    
    # Add port specification
    if ports and scan_type != "ping":
        # Handle case where ports might be passed as a list instead of string
        if isinstance(ports, list):
            ports = ",".join(str(p) for p in ports)
        
        if isinstance(ports, str) and ports.startswith("top-ports"):
            num_ports = ports.split()[-1]
            cmd_parts.extend(["--top-ports", num_ports])
        elif "," in str(ports) or "-" in str(ports):
            cmd_parts.extend(["-p", str(ports)])
        else:
            cmd_parts.extend(["-p", str(ports)])
    elif scan_type == "udp":
        cmd_parts.extend(["--top-ports", "100"])
    
    # Add useful flags
    cmd_parts.extend(["-n", "--open", "--reason"])
    
    # Add timing
    if scan_type == "stealth":
        cmd_parts.extend(["-T2"])
    elif scan_type in ["comprehensive", "aggressive"]:
        cmd_parts.extend(["-T4"])
    else:
        cmd_parts.extend(["-T3"])
    
    # Add target
    cmd_parts.append(target)
    
    return " ".join(cmd_parts)

def _parse_nmap_output(output: str, scan_type: str) -> Dict[str, Any]:
    """
    Parse nmap text output into structured data.
    
    Args:
        output: Raw nmap output text
        scan_type: Type of scan that was performed
        
    Returns:
        Dict containing parsed results
    """
    result = {
        "hosts_found": 0,
        "ports_found": 0,
        "hosts": {},
        "summary": None
    }
    
    lines = output.split('\n')
    current_host = None
    
    for line in lines:
        line = line.strip()
        
        # Parse host information
        host_match = re.search(r'Nmap scan report for (.+)', line)
        if host_match:
            host_info = host_match.group(1)
            
            # Extract IP and hostname if present
            if '(' in host_info and ')' in host_info:
                # Format: hostname (ip)
                hostname = host_info.split('(')[0].strip()
                ip = host_info.split('(')[1].split(')')[0].strip()
            else:
                # Just IP or hostname
                hostname = None
                ip = host_info.strip()
            
            current_host = ip
            result["hosts"][current_host] = {
                "ip": ip,
                "hostname": hostname,
                "status": "up",
                "ports": {},
                "os_info": None,
                "mac_address": None
            }
            result["hosts_found"] += 1
            continue
        
        # Parse port information
        if current_host and '/' in line and ('open' in line or 'closed' in line or 'filtered' in line):
            port_match = re.search(r'(\d+)/(tcp|udp)\s+(\w+)\s+(.+)', line)
            if port_match:
                port_num = port_match.group(1)
                protocol = port_match.group(2)
                state = port_match.group(3)
                service_info = port_match.group(4).strip()
                
                port_key = f"{port_num}/{protocol}"
                result["hosts"][current_host]["ports"][port_key] = {
                    "port": int(port_num),
                    "protocol": protocol,
                    "state": state,
                    "service": service_info,
                    "version": None
                }
                
                if state == "open":
                    result["ports_found"] += 1
                
                # Parse service version if available
                if ' ' in service_info:
                    parts = service_info.split(' ', 1)
                    result["hosts"][current_host]["ports"][port_key]["service"] = parts[0]
                    result["hosts"][current_host]["ports"][port_key]["version"] = parts[1]
        
        # Parse OS detection
        if current_host and line.startswith('Running:'):
            os_info = line.replace('Running:', '').strip()
            result["hosts"][current_host]["os_info"] = os_info
        
        # Parse MAC address
        if current_host and line.startswith('MAC Address:'):
            mac_match = re.search(r'MAC Address: ([A-Fa-f0-9:]{17})', line)
            if mac_match:
                result["hosts"][current_host]["mac_address"] = mac_match.group(1)
        
        # Parse summary line
        if 'Nmap done:' in line:
            result["summary"] = line.strip()
    
    return result

def generate_scan_report(scan_result: Dict[str, Any], format_type: str = "text") -> str:
    """
    Generate formatted scan report.
    
    Args:
        scan_result: Result dictionary from nmap scan
        format_type: Report format (text, json, markdown)
        
    Returns:
        Formatted report string
    """
    if format_type == "json":
        return json.dumps(scan_result, indent=2)
    
    elif format_type == "markdown":
        return _generate_markdown_report(scan_result)
    
    else:  # text format
        return _generate_text_report(scan_result)

def _generate_text_report(scan_result: Dict[str, Any]) -> str:
    """Generate text format report."""
    report = [f"Nmap Scan Report", f"{'=' * 50}", f"Scan Type: {scan_result.get('scan_type', 'unknown')}",
              f"Target: {scan_result.get('target', 'unknown')}",
              f"Start Time: {scan_result.get('start_time', 'unknown')}",
              f"Duration: {scan_result.get('duration_seconds', 0)}s",
              f"Hosts Found: {scan_result.get('hosts_found', 0)}", f"Open Ports: {scan_result.get('ports_found', 0)}",
              ""
              ]

    for host_ip, host_data in scan_result.get("hosts", {}).items():
        report.append(f"Host: {host_ip}")
        if host_data.get("hostname"):
            report.append(f"   Hostname: {host_data['hostname']}")
        if host_data.get("mac_address"):
            report.append(f"   MAC: {host_data['mac_address']}")
        if host_data.get("os_info"):
            report.append(f"   OS: {host_data['os_info']}")
        
        open_ports = [p for p, data in host_data.get("ports", {}).items() if data["state"] == "open"]
        if open_ports:
            report.append(f"   Open Ports:")
            for port_key in open_ports:
                port_data = host_data["ports"][port_key]
                service = port_data.get("service", "unknown")
                version = port_data.get("version", "")
                report.append(f"     {port_key} - {service} {version}".strip())
        report.append("")
    
    if scan_result.get("summary"):
        report.append(f"Summary: {scan_result['summary']}")
    
    return "\n".join(report)

def _generate_markdown_report(scan_result: Dict[str, Any]) -> str:
    """Generate Markdown format report."""
    report = ["# Nmap Scan Report", "", "## Scan Details",
              f"- **Scan Type:** {scan_result.get('scan_type', 'unknown')}",
              f"- **Target:** {scan_result.get('target', 'unknown')}",
              f"- **Start Time:** {scan_result.get('start_time', 'unknown')}",
              f"- **Duration:** {scan_result.get('duration_seconds', 0)}s",
              f"- **Hosts Found:** {scan_result.get('hosts_found', 0)}",
              f"- **Open Ports:** {scan_result.get('ports_found', 0)}", ""
              ]

    if scan_result.get("hosts"):
        report.append("## Host Results")
        
        for host_ip, host_data in scan_result["hosts"].items():
            report.append(f"### {host_ip}")
            
            if host_data.get("hostname"):
                report.append(f"**Hostname:** {host_data['hostname']}")
            if host_data.get("mac_address"):
                report.append(f"**MAC Address:** {host_data['mac_address']}")
            if host_data.get("os_info"):
                report.append(f"**OS:** {host_data['os_info']}")
            
            open_ports = [p for p, data in host_data.get("ports", {}).items() if data["state"] == "open"]
            if open_ports:
                report.append("")
                report.append("**Open Ports:**")
                report.append("| Port | Service | Version |")
                report.append("|------|---------|---------|")
                
                for port_key in open_ports:
                    port_data = host_data["ports"][port_key]
                    service = port_data.get("service", "unknown")
                    version = port_data.get("version", "")
                    report.append(f"| {port_key} | {service} | {version} |")
            
            report.append("")
    
    if scan_result.get("summary"):
        report.append("## Summary")
        report.append(f"{scan_result['summary']}")
    
    return "\n".join(report)

# Quick test function for development
def test_nmap_wrapper():
    """Test function for development purposes."""
    print("Testing nmap wrapper module...")
    
    # Test nmap detection
    print("\n1. Testing nmap detection:")
    nmap_check = detect_tool_installation("nmap")
    if nmap_check["found"]:
        print(f"   nmap found at: {nmap_check['path']}")
        if nmap_check.get("version"):
            print(f"   Version: {nmap_check['version']}")
    else:
        print(f"   nmap not found. Install with: {nmap_check.get('install_command', 'package manager')}")
        return None
    
    # Test localhost scan
    print("\n2. Testing quick localhost scan:")
    result = quick_port_scan("127.0.0.1", ports="22,80,443", silent=False)
    
    if result["success"]:
        print("   Scan completed successfully")
        report = generate_scan_report(result, "text")
        print("\n3. Generated report:")
        print(report)
    else:
        print(f"   Scan failed: {result.get('error', 'Unknown error')}")
    
    return result

# v3 Registry Integration
def get_module_tools():
    """
    Get properly defined tool metadata for the nmap wrapper module.
    This ensures the chatbot understands the correct function signatures.
    """
    from core.tools_registry import ToolMetadata, ParameterInfo, ParameterType, ToolCategory
    
    return {
        "nmap_scan": ToolMetadata(
            name="nmap_scan",
            function_name="run_nmap_scan",
            module_path="pentest.nmap_wrapper",
            description="Run nmap scan with specified parameters on remote targets",
            category=ToolCategory.PENTESTING,
            parameters={
                "target": ParameterInfo(ParameterType.STRING, required=True, 
                                      description="Target IP, hostname, or CIDR range"),
                "scan_type": ParameterInfo(ParameterType.STRING, required=False, default="basic",
                                         choices=["basic", "syn", "tcp", "udp", "ping", "stealth", "version", "os", "comprehensive"],
                                         description="Type of scan to perform"),
                "ports": ParameterInfo(ParameterType.STRING, required=False,
                                     description="Port specification (e.g., '80,443', '1-1000', 'top-ports 100')"),
                "timeout": ParameterInfo(ParameterType.INTEGER, required=False,
                                       description="Scan timeout in seconds"),
                "silent": ParameterInfo(ParameterType.BOOLEAN, required=False, default=False,
                                      description="Suppress console output")
            },
            requires_external_tool=True,
            external_tool_name="nmap",
            examples=["nmap_scan 192.168.1.1", "nmap_scan 192.168.1.0/24 scan_type=ping", "nmap_scan google.com scan_type=version ports=80,443"]
        ),
        "quick_port_scan": ToolMetadata(
            name="quick_port_scan",
            function_name="quick_port_scan",
            module_path="pentest.nmap_wrapper",
            description="Quick port scan for common services on remote targets",
            category=ToolCategory.PENTESTING,
            parameters={
                "target": ParameterInfo(ParameterType.STRING, required=True,
                                      description="Target IP or hostname"),
                "ports": ParameterInfo(ParameterType.STRING, required=False, default="80,443,22,21,25,53,110,143,993,995",
                                     description="Comma-separated list of ports to scan"),
                "silent": ParameterInfo(ParameterType.BOOLEAN, required=False, default=False,
                                      description="Suppress console output")
            },
            requires_external_tool=True,
            external_tool_name="nmap",
            examples=["quick_port_scan 192.168.1.1", "quick_port_scan google.com ports=80,443,8080"]
        ),
        "network_discovery": ToolMetadata(
            name="network_discovery",
            function_name="network_discovery",
            module_path="pentest.nmap_wrapper",
            description="Discover live hosts on a network",
            category=ToolCategory.PENTESTING,
            parameters={
                "network": ParameterInfo(ParameterType.STRING, required=True,
                                       description="Network in CIDR notation (e.g., '192.168.1.0/24')"),
                "silent": ParameterInfo(ParameterType.BOOLEAN, required=False, default=False,
                                      description="Suppress console output")
            },
            requires_external_tool=True,
            external_tool_name="nmap",
            examples=["network_discovery 192.168.1.0/24", "network_discovery 10.0.0.0/16"]
        ),
        "service_version_scan": ToolMetadata(
            name="service_version_scan",
            function_name="service_version_scan",
            module_path="pentest.nmap_wrapper",
            description="Scan for service versions on open ports of remote targets",
            category=ToolCategory.PENTESTING,
            parameters={
                "target": ParameterInfo(ParameterType.STRING, required=True,
                                      description="Target IP or hostname"),
                "ports": ParameterInfo(ParameterType.STRING, required=False,
                                     description="Port specification (default: top 1000 ports)"),
                "silent": ParameterInfo(ParameterType.BOOLEAN, required=False, default=False,
                                      description="Suppress console output")
            },
            requires_external_tool=True,
            external_tool_name="nmap",
            examples=["service_version_scan 192.168.1.1", "service_version_scan google.com ports=80,443"]
        ),
        "os_detection_scan": ToolMetadata(
            name="os_detection_scan",
            function_name="os_detection_scan",
            module_path="pentest.nmap_wrapper",
            description="Attempt to detect target operating system of remote hosts",
            category=ToolCategory.PENTESTING,
            parameters={
                "target": ParameterInfo(ParameterType.STRING, required=True,
                                      description="Target IP or hostname"),
                "silent": ParameterInfo(ParameterType.BOOLEAN, required=False, default=False,
                                      description="Suppress console output")
            },
            requires_external_tool=True,
            external_tool_name="nmap",
            examples=["os_detection_scan 192.168.1.1", "os_detection_scan google.com"]
        ),
        "comprehensive_scan": ToolMetadata(
            name="comprehensive_scan",
            function_name="comprehensive_scan",
            module_path="pentest.nmap_wrapper",
            description="Comprehensive scan with service detection and OS fingerprinting of remote targets",
            category=ToolCategory.PENTESTING,
            parameters={
                "target": ParameterInfo(ParameterType.STRING, required=True,
                                      description="Target IP or hostname"),
                "silent": ParameterInfo(ParameterType.BOOLEAN, required=False, default=False,
                                      description="Suppress console output")
            },
            requires_external_tool=True,
            external_tool_name="nmap",
            examples=["comprehensive_scan 192.168.1.1", "comprehensive_scan google.com"]
        )
    }


if __name__ == "__main__":
    test_nmap_wrapper()